% Function call order: gillespie (-> Compute_Multiple_Simulations (-> seed and Execute_Gillespie_Algorithm))


% This wrapper function takes as input the following arguments:
% 1) START_POPULATION
% 2) GROWTH_RATE
% 3) CARRYING_CAPACITY (unused)
% 4) CROWDING_COEFFICIENT
% 5) ITERATIONS_GILLEPSIE, different from ITERATIONS (much greater, since time is generated by a Poisson process)
% 6) NSIMULATIONS_GILLEPSIE, same as NSIMULATIONS

% This function outputs:
% 1) Gillespie_Model_Times, time "points" corresponding to the iteration
% means (actually they are iteration time means, across all simulations)
% 2) Gillespie_Model_Values, corresponding to the iteration means
% (we had to extract the mean current N at each time point over the individual simulations, 
% by weighting each count by the length of time that it existed, 
% divided by the total time of that particular window)


function [Gillespie_Model_Times, Gillespie_Model_Values] = gillespie(START_POPULATION_, GROWTH_RATE_, CARRYING_CAPACITY_, CROWDING_COEFFICIENT_, ITERATIONS_GILLEPSIE_, NSIMULATIONS_GILLEPSIE_)
    filename = "gillespie_datasave.mat";
    % if the execution with same input parameters has been already carried out and saved
    % do not compute it again (it takes a lot of time)
    compute_algoritm = true;
    % Check if the output file of Gillespie exists
    if isfile(filename)
        % Load file
        load(filename);
        % Check if the variables have been defined (are the input parameters the same as the one provided?)
        if exist('Gillespie_Model','var') && exist("START_POPULATION",'var') && exist("GROWTH_RATE",'var') && exist("CARRYING_CAPACITY",'var') && exist("CROWDING_COEFFICIENT",'var') && exist("ITERATIONS_GILLEPSIE",'var') && exist("NSIMULATIONS_GILLEPSIE",'var')
             % Check if the parameters are equal
            if START_POPULATION == START_POPULATION_ && GROWTH_RATE == GROWTH_RATE_ && CARRYING_CAPACITY == CARRYING_CAPACITY_ && CROWDING_COEFFICIENT == CROWDING_COEFFICIENT_ && ITERATIONS_GILLEPSIE == ITERATIONS_GILLEPSIE_ && NSIMULATIONS_GILLEPSIE == NSIMULATIONS_GILLEPSIE_
                % Execution has been saved correctly so it can be reused
                compute_algoritm = false;
                fprintf("Gillespie already computed \n");
            end
        end
    end

    % Save/overwrite input parameters
    START_POPULATION = START_POPULATION_;
    GROWTH_RATE = GROWTH_RATE_;
    CARRYING_CAPACITY = CARRYING_CAPACITY_;
    CROWDING_COEFFICIENT = CROWDING_COEFFICIENT_;
    ITERATIONS_GILLEPSIE = ITERATIONS_GILLEPSIE_;
    NSIMULATIONS_GILLEPSIE = NSIMULATIONS_GILLEPSIE_;
    
    % If the algorithm needs to be re-run, executed from scratch
    if compute_algoritm == true
        % run the function that contains the Gillespie algorithm and deals
        % with multiple simulations and their averaging
        [Gillespie_Model_Times, Gillespie_Model_Values] = Compute_Multiple_Simulations(START_POPULATION, GROWTH_RATE, CARRYING_CAPACITY, CROWDING_COEFFICIENT, ITERATIONS_GILLEPSIE, NSIMULATIONS_GILLEPSIE);
        Gillespie_Model = [Gillespie_Model_Times; Gillespie_Model_Values];
        % save model and all its parameters/variables
        save(filename, 'Gillespie_Model', 'START_POPULATION', 'GROWTH_RATE', 'CARRYING_CAPACITY', 'CROWDING_COEFFICIENT', 'ITERATIONS_GILLEPSIE', 'NSIMULATIONS_GILLEPSIE');
    end    

    Gillespie_Model_Times = Gillespie_Model(1, :);
    Gillespie_Model_Values = Gillespie_Model(2, :);
end

% This function takes the same input and returns the same output as above and
% performs the averaging of time points and population values
% across simulations, resulting from the application of the Gillespie
% algorithm
function [Gillespie_Model_Times, Gillespie_Model_Values] = Compute_Multiple_Simulations(START_POPULATION, GROWTH_RATE, CARRYING_CAPACITY, CROWDING_COEFFICIENT, ITERATIONS_GILLEPSIE, NSIMULATIONS_GILLEPSIE)
    
    tmp_array_times = zeros(NSIMULATIONS_GILLEPSIE, ITERATIONS_GILLEPSIE);
    tmp_array_dt = zeros(NSIMULATIONS_GILLEPSIE, ITERATIONS_GILLEPSIE);
    tmp_array_values = zeros(NSIMULATIONS_GILLEPSIE, ITERATIONS_GILLEPSIE);
    
    Gillespie_Model_Values = zeros(1, ITERATIONS_GILLEPSIE);
    Gillespie_Model_Times = zeros(1, ITERATIONS_GILLEPSIE);

    % clean old seeds
    clear seed;

    for i = 1:NSIMULATIONS_GILLEPSIE
        SEED = seed(); % for reproducibility of each single simulation
        % This function actually applies the exact Gillespie algorithm to
        % simulate logistic growth
        [times, dt, values] = Execute_Gillespie_Algorithm(START_POPULATION, GROWTH_RATE, CARRYING_CAPACITY, CROWDING_COEFFICIENT, ITERATIONS_GILLEPSIE, SEED);
        tmp_array_times(i, :) = times;
        tmp_array_dt(i, :) = dt;
        tmp_array_values(i, :) = values;
    end

    % Compute iteration means and time "points"
    % code adapted from: https://www.rpgroup.caltech.edu/ncbs_pboc/code/t06_gillespie_algorithm.html
    % N.B. parfor is a parallel for loop, it is faster than a for loop
    parfor i = 1:ITERATIONS_GILLEPSIE
        % iterations are the same, so to obtain the average population
        % values, sum all the population values corresponding to iteration
        % i, after multiplying each of them by its dt/tau (length of time it
        % existed), then divide by the total time up to that iteration i (weighted mean)
        Gillespie_Model_Values(i) = sum(tmp_array_values(:, i) .* tmp_array_dt(:, i)) ./ sum(tmp_array_dt(:, i));
        % iterations are the same, so to obtain the average time values
        % simply take the mean across all simulations for iteration i
        Gillespie_Model_Times(i) = mean(tmp_array_times(:, i));
    end
end

% This function takes as input the following arguments:
% 1) START_POPULATION
% 2) GROWTH_RATE
% 3) CARRYING_CAPACITY (unused)
% 4) CROWDING_COEFFICIENT
% 5) ITERATIONS
% 6) SEED, for reproducibility of each single simulation

% This function outputs:
% 1) Time, corresponding to subsequent event of birth/death (poisson
% distributed) (real numbers)
% 2) Dt, waiting time (tau) between subsequent events (exponentially
% distributed) (real numbers)
% 3) Population, N values (natural numbers)

% This function implements the exact Gillespie algorithm to stochastically
% simulate logistic growth
function [Time, Dt, Population] = Execute_Gillespie_Algorithm(START_POPULATION, GROWTH_RATE, CARRYING_CAPACITY, CROWDING_COEFFICIENT, ITERATIONS, SEED)
    rng(SEED) % for reproducibility of each single simulation
    Population = zeros(1, ITERATIONS);
    Population(1) = START_POPULATION; % initial population is non-zero
    Time = zeros(1, ITERATIONS);
    Time(1) = 1; % initial time is 1
    Dt = zeros(1, ITERATIONS);
    Dt(1) = 1; % so tau is 1
    % draw multiple random numbers from the uniform distribution
    random_numbers = rand(1, ITERATIONS);

    for i = 2:ITERATIONS
        % compute transition rates
        growth_rate = GROWTH_RATE * Population(i-1); % r * current N (first part of logistic equation) for N->N+1
        death_rate = Population(i-1) * Population(i-1) * CROWDING_COEFFICIENT;% r/L * current N^2 (second part of logistic equation) for N->N-1
        % draw a random number from the exponential distribution to get
        % next waiting time, taking into account/weigthing by the updated rates
        tau = exprnd(1/(growth_rate + death_rate)); % note lambda
        % transition probabilities
        if random_numbers(i) * (growth_rate + death_rate) < growth_rate
            Population(i) = Population(i-1) + 1; % P(N->N+1)
        else
            Population(i) = Population(i-1) - 1; % P(N->N-1)
        end % mutually exclusive
        % update time window
        Time(i) = Time(i-1) + tau;
        % save tau
        Dt(i) = tau;    
    end
end